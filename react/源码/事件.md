> 注: 从v17.0.0开始, React 不会再将事件处理添加到 document 上, 而是将事件处理添加到渲染 React 树的根 DOM 容器中.
> 注: react的事件体系, 不是全部都通过事件委托来实现的. 有一些特殊情况, 是直接绑定到对应 DOM 元素上的(如:scroll, load), 它们都通过 listenToNonDelegatedEvent 函数进行绑定.上述特殊事件最大的不同是监听的 DOM 元素不同, 除此之外, 其他地方的实现与正常事件大体一致.

#### 事件绑定
React在启动时会创建全局对象, 其中在创建fiberRoot对象时, 调用createRootImpl:
```javascript
function createRootImpl(
  container: Container,
  tag: RootTag,
  options: void | RootOptions,
) {
  // 应用根元素
  var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
  // 绑定支持的事件
  listenToAllSupportedEvents(rootContainerElement);
}
```
`listenToAllSupportedEvents` 函数, 实际上完成了事件代理:
```javascript
function listenToAllSupportedEvents(rootContainerElement) {
  {
    // 1. 节流优化, 保证全局注册只被调用一次
    if (rootContainerElement[listeningMarker]) {
      return;
    }

    rootContainerElement[listeningMarker] = true;
    // 2. 遍历allNativeEvents 监听冒泡和捕获阶段的事件(allNativeEvents 是一个 set 集合，保存了大多数的浏览器事件)
    allNativeEvents.forEach(function (domEventName) {
      // nonDelegatedEvents 保存了不会冒泡的事件, 对于不会冒泡的事件, 只绑定捕获事件
      if (!nonDelegatedEvents.has(domEventName)) {
        // 在冒泡阶段绑定事件
        listenToNativeEvent(domEventName, false, rootContainerElement, null);
      }
      /* 在捕获阶段绑定事件 */
      listenToNativeEvent(domEventName, true, rootContainerElement, null);
    });
  }
}
```
核心逻辑:

1.节流优化, 保证全局注册只被调用一次.
2.遍历 `allNativeEvents`, 调用 `listenToNativeEvent` 监听冒泡和捕获阶段的事件,
`allNativeEvents` 包括了大量的原生事件名称, 它是在 DOMPluginEventSystem.js 中被初始化
```javascript
function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
  // 获取事件 flag
  var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var target = rootContainerElement; // selectionchange needs to be attached to the document
  // otherwise it won't capture incoming events that are only
  // triggered on the document directly.

  if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) {
    target = rootContainerElement.ownerDocument;
  } 


  if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
    if (domEventName !== 'scroll') {
      return;
    }

    eventSystemFlags |= IS_NON_DELEGATED;
    target = targetElement;
  }

  // 获取根节点已经绑定的全部事件集合
  var listenerSet = getEventListenerSet(target);
  // 根据事件所处的阶段(冒泡, 捕获)获取绑定事件的类型
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
  // we need to trap an event listener onto the target.

  // 利用set数据结构, 保证相同的事件类型只会被注册一次.
  if (!listenerSet.has(listenerSetKey)) {
    if (isCapturePhaseListener) {
      // 添加捕获阶段标识
      eventSystemFlags |= IS_CAPTURE_PHASE;
    }

    // 绑定监听事件
    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    // 将当前事件名称添加到绑定事件集合中
    listenerSet.add(listenerSetKey);
  }
}
```
```javascript
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
  // 1. 构造监听事件(点击事件的包裹函数)
  var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
  // active and not passive.

  var isPassiveListener = undefined;

  if (passiveBrowserEventsSupported) {
    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {
      isPassiveListener = true;
    }
  }

  targetContainer =  targetContainer;
  var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we

  // 2. 注册事件监听
  // 捕获事件
  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
    }
  } else {
    // 冒泡事件
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
  }
}
```
```javascript
function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
  var eventPriority = getEventPriorityForPluginSystem(domEventName);
  var listenerWrapper;

  // 1.根据事件优先级设置 listenerWrapper
  switch (eventPriority) {
    // 离散事件(优先级最高, 包括click, keyDown, input等事件)
    // DiscreteEvent: 0
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;

    // 用户阻塞事件(优先级适中, 包括drag, scroll等事件)
    // UserBlockingEvent: 1
    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;
    
    // 连续事件(优先级最低,包括animation, load等事件)
    // ContinuousEvent: 2
    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  // 2.返回 listenerWrapper(domEventName: 事件名称, eventSystemFlags: 事件 flag, targetContainer: 应用根元素)
  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}
```