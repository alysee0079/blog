1.闭包与命名空间
每个 js 文件都是使用 IIFE 包裹的，各个 js 文件分别在不同的词法作用域中，相互隔离，最后通过闭包的方式暴露变量。每个闭包都是单独一个文件,
每个文件仍然通过 script 标签的方式下载，标签的顺序就 是模块的依赖关系
这样做的意义：
各个 js 文件之间避免了变量重名干扰，并且最少的暴露变量，避免全局污染。
模块外部不能轻易的修改闭包内部的变量，程序的稳定性增加。
模块与外部的连接通过 IIFE 传参，语义化更好，清晰地知道有哪些依赖。
4.CommonJs
Commonjs 规范具有以下特点：
原生 Module 对象，每个文件都是一个 Module 实例
文件内通过 require 对象引入指定模块
所有文件加载均是同步完成
通过 module 关键字暴露内容
每个模块加载一次之后就会被缓存
模块编译本质上是沙箱编译
由于使用了 Node 的 api，只能在服务端环境上运行
Commonjs 优点在于：
强大的查找模块功能，开发十分方便
标准化的输入输出，非常统一
每个文件引入自己的依赖，最终形成文件依赖树
模块缓存机制，提高编译效率
利用 node 实现文件同步读取
依靠注入变量的沙箱编译实现模块化
5.AMD 和 RequireJS
AMD 是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。
所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（前置依赖），这个回调函数才会运行。
RequireJs:
RequireJs 有两个最鲜明的特点：
依赖前置：动态创建<script>引入依赖，在<script>标签的 onload 事件监听文件加载完毕；一个模块的回调函数必须得等到所有依赖都加载完毕之后，才可执行，类似 Promise.all。
配置文件：有一个 main 文件，配置不同模块的路径，以及 shim 不满足 AMD 规范的 js 文件。
主要是以下优点：
动态并行加载 js，依赖前置，无需再考虑 js 加载顺序问题。
核心还是注入变量的沙箱编译，解决模块化问题。
规范化输入输出，使用起来方便。
对于不满足 AMD 规范的文件可以很好地兼容。
6.CMD 和 SeaJs
CMD 规范（2011）具有以下特点：
define 定义模块，require 加载模块，exports 暴露变量。
不同于 AMD 的依赖前置，CMD 推崇依赖就近（需要的时候再加载）
推崇 api 功能单一，一个模块干一件事。
SeaJs 核心特点：
需要配置模块对应的 url。
入口文件执行之后，根据文件内的依赖关系整理出依赖树，然后通过插入<script>标签加载依赖。
依赖加载完毕之后，执行根 factory。
在 factory 中遇到 require，则去执行对应模块的 factory，实现就近依赖。
类似 Commonjs，对所有模块进行缓存（模块的 url 就是 id）。
类似 Commonjs，可以使用相对路径加载模块。
可以向 RequireJs 一样前置依赖，但是推崇就近依赖。
exports 和 return 都可以暴露变量。
7.ES6 中的模块化
ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。
CommonJS 模块输出的是值的拷贝(原始值的拷贝)，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 输出值的引用
ES6 静态编译，CommonJS 运行时加载

#### ES6 模块与 CommonJS 模块的差异

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。
